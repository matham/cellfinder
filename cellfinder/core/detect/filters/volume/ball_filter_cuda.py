from functools import lru_cache

import numpy as np
import torch
import torch.nn.functional as F
from numba.core import types

from cellfinder.core.tools.array_operations import bin_mean_3d
from cellfinder.core.tools.geometry import make_sphere

DEBUG = False

uint32_3d_type = types.uint32[:, :, :]
bool_3d_type = types.bool_[:, :, :]
float_3d_type = types.float64[:, :, :]


@lru_cache(maxsize=50)
def get_kernel(ball_xy_size: int, ball_z_size: int) -> np.ndarray:
    # Create a spherical kernel.
    #
    # This is done by:
    # 1. Generating a binary sphere at a resolution *upscale_factor* larger
    #    than desired.
    # 2. Downscaling the binary sphere to get a 'fuzzy' sphere at the
    #    original intended scale
    upscale_factor: int = 7
    upscaled_kernel_shape = (
        upscale_factor * ball_xy_size,
        upscale_factor * ball_xy_size,
        upscale_factor * ball_z_size,
    )
    upscaled_ball_centre_position = (
        np.floor(upscaled_kernel_shape[0] / 2),
        np.floor(upscaled_kernel_shape[1] / 2),
        np.floor(upscaled_kernel_shape[2] / 2),
    )
    upscaled_ball_radius = upscaled_kernel_shape[0] / 2.0

    sphere_kernel = make_sphere(
        upscaled_kernel_shape,
        upscaled_ball_radius,
        upscaled_ball_centre_position,
    )
    sphere_kernel = sphere_kernel.astype(np.float64)
    kernel = bin_mean_3d(
        sphere_kernel,
        bin_height=upscale_factor,
        bin_width=upscale_factor,
        bin_depth=upscale_factor,
    )

    assert (
        kernel.shape[2] == ball_z_size
    ), "Kernel z dimension should be {}, got {}".format(
        ball_z_size, kernel.shape[2]
    )

    return kernel


class BallFilter:
    """
    A 3D ball filter.

    This runs a spherical kernel across the (x, y) dimensions
    of a *ball_z_size* stack of planes, and marks pixels in the middle
    plane of the stack that have a high enough intensity within the
    spherical kernel.
    """

    def __init__(
        self,
        plane_width: int,
        plane_height: int,
        ball_xy_size: int,
        ball_z_size: int,
        overlap_fraction: float,
        tile_step_width: int,
        tile_step_height: int,
        threshold_value: int,
        soma_centre_value: int,
        batch_size: int = 1,
    ):
        """
        Parameters
        ----------
        plane_width, plane_height :
            Width/height of the planes.
        ball_xy_size :
            Diameter of the spherical kernel in the x/y dimensions.
        ball_z_size :
            Diameter of the spherical kernel in the z dimension.
            Equal to the number of planes that stacked to filter
            the central plane of the stack.
        overlap_fraction :
            The fraction of pixels within the spherical kernel that
            have to be over *threshold_value* for a pixel to be marked
            as having a high intensity.
        tile_step_width, tile_step_height :
            Width/height of individual tiles in the mask generated by
            2D filtering.
        threshold_value :
            Value above which an individual pixel is considered to have
            a high intensity.
        soma_centre_value :
            Value used to mark pixels with a high enough intensity.
        """
        self.ball_xy_size = ball_xy_size
        self.ball_z_size = ball_z_size
        self.overlap_fraction = overlap_fraction
        self.tile_step_width = tile_step_width
        self.tile_step_height = tile_step_height

        self.THRESHOLD_VALUE = threshold_value
        self.SOMA_CENTRE_VALUE = soma_centre_value

        kernel = np.moveaxis(get_kernel(ball_xy_size, ball_z_size), 2, 0)
        self.overlap_threshold = np.sum(self.overlap_fraction * kernel)
        self.kernel_xy = kernel.shape[1:]
        kernel = torch.from_numpy(kernel).type(torch.float32)
        self.kernel = kernel.unsqueeze(0).unsqueeze(0).to(device="cuda")

        # Stores the current planes that are being filtered
        # first axis is z for faster rotating the z-axis
        self.volume = torch.from_numpy(
            np.empty(
                (ball_z_size, plane_width, plane_height),
                dtype=np.float32,
            )
        ).to(device="cuda")
        # Index of the middle plane in the volume
        self.middle_z_idx = int(np.floor(ball_z_size / 2))
        self._num_z_added = 0

        # first axis is z
        tile_width = int(np.ceil(plane_width / tile_step_width))
        tile_height = int(np.ceil(plane_height / tile_step_height))
        self.inside_brain_tiles = torch.from_numpy(
            np.empty(
                (
                    ball_z_size,
                    tile_width,
                    tile_height,
                ),
                dtype=np.bool_,
            )
        ).to(device="cuda")

        # Get extents of image that are covered by tiles
        tile_mask_covered_img_width = tile_width * self.tile_step_width
        tile_mask_covered_img_height = tile_height * self.tile_step_height
        # Get maximum offsets for the ball within the tiled plane
        max_width = tile_mask_covered_img_width - self.ball_xy_size
        max_height = tile_mask_covered_img_height - self.ball_xy_size
        self.tiled_xy = max_width, max_height

    @property
    def ready(self) -> bool:
        """
        Return `True` if enough planes have been appended to run the filter.
        """
        return self._num_z_added >= self.ball_z_size

    def append(self, plane: np.ndarray, mask: np.ndarray) -> None:
        """
        Add a new 2D plane to the filter.
        """
        if DEBUG:
            assert [e for e in plane.shape[:2]] == [
                e for e in self.volume.shape[1:]
            ], 'plane shape mismatch, expected "{}", got "{}"'.format(
                [e for e in self.volume.shape[1:]],
                [e for e in plane.shape[:2]],
            )
            assert [e for e in mask.shape[:2]] == [
                e for e in self.inside_brain_tiles.shape[1:]
            ], 'mask shape mismatch, expected"{}", got {}"'.format(
                [e for e in self.inside_brain_tiles.shape[1:]],
                [e for e in mask.shape[:2]],
            )

        if self.ready:
            # Shift everything down by one to make way for the new plane
            # this is faster than np.roll, especially with z-axis first
            self.volume = torch.roll(self.volume, -1, 0)
            self.inside_brain_tiles = torch.roll(
                self.inside_brain_tiles, -1, 0
            )

        # index for *next* slice is num we added *so far* until max
        idx = min(self._num_z_added, self.ball_z_size - 1)
        self._num_z_added += 1

        # Add the new plane to the top of volume and inside_brain_tiles
        self.volume[idx, :, :] = plane
        self.inside_brain_tiles[idx, :, :] = mask

    def get_middle_planes(self) -> np.ndarray:
        """
        Get the plane in the middle of self.volume.
        """
        return [
            self.volume[self.middle_z_idx, :, :]
            .cpu()
            .numpy()
            .astype(np.uint32)
            .copy()
        ]

    def walk(self, parallel: bool = False) -> None:
        # **don't** pass parallel as keyword arg - numba struggles with it
        # Highly optimised because most time critical
        max_width, max_height = self.tiled_xy

        inside = self.inside_brain_tiles[self.middle_z_idx, :, :]
        w, h = inside.shape
        # inside = inside.view(w, 1, h).expand(w,
        # self.tile_step_width, h).contiguous().view(-1, h)
        inside = (
            self.inside_brain_tiles[self.middle_z_idx, :, :]
            .repeat_interleave(self.tile_step_width, dim=0)
            .repeat_interleave(self.tile_step_height, dim=1)
        )
        # max_xxx may be larger than actual volume
        sub_volume = self.volume[:, :max_width, :max_height]
        # it may be larger if the last tile sticks outside the volume

        volume_tresh = (
            (sub_volume >= self.THRESHOLD_VALUE)
            .unsqueeze(0)
            .unsqueeze(0)
            .type(self.kernel.dtype)
        )
        overlaps = F.conv3d(volume_tresh, self.kernel, stride=1)[0, 0, 0, :, :]
        inside = inside[: overlaps.shape[0], : overlaps.shape[1]]

        sub_volume[
            self.middle_z_idx, : overlaps.shape[0], : overlaps.shape[1]
        ][torch.logical_and(overlaps, inside)] = self.SOMA_CENTRE_VALUE
