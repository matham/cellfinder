from dataclasses import dataclass
from functools import cached_property
from typing import Callable, Optional, Tuple

import numpy as np
from brainglobe_utils.general.system import get_num_processes

from cellfinder.core.tools.tools import (
    get_data_converter,
    get_max_possible_int_value,
)


@dataclass
class DetectionSettings:
    """

    plane_width, plane_height :
        Width/height of the planes.
    ball_xy_size :
        Diameter of the spherical kernel in the x/y dimensions.
    ball_z_size :
        Diameter of the spherical kernel in the z dimension.
        Equal to the number of planes that stacked to filter
        the central plane of the stack.
    overlap_fraction :
        The fraction of pixels within the spherical kernel that
        have to be over *threshold_value* for a pixel to be marked
        as having a high intensity.
    tile_step_width, tile_step_height :
        Width/height of individual tiles in the mask generated by
        2D filtering.
    threshold_value :
        Value above which an individual pixel is considered to have
        a high intensity.
    soma_centre_value :
        Value used to mark pixels with a high enough intensity.


    n_iter (int): The number of iterations to perform. Default is 10.
    """

    plane_shape: Tuple[int, int]
    plane_original_np_dtype: np.dtype
    filterting_dtype: str

    voxel_sizes: Tuple[float, float, float]
    soma_spread_factor: float
    soma_diameter: int
    soma_diameter_um: float
    max_cluster_size: int
    max_cluster_size_um3: float
    ball_xy_size: int
    ball_xy_size_um: float
    ball_z_size: int
    ball_z_size_um: float

    start_plane: int
    end_plane: int
    n_planes: int

    n_free_cpus: int

    ball_overlap_fraction: float
    log_sigma_size: float
    n_sds_above_mean_thresh: float

    outlier_keep: bool = False
    artifact_keep: bool = False

    save_planes: bool = False
    plane_directory: Optional[str] = None

    batch_size: int = 4
    torch_device: str = "cpu"

    num_prefetch_batches: int = 2

    n_splitting_iter: int = 10

    @cached_property
    def filter_data_converter_func(self) -> Callable[[np.ndarray], np.ndarray]:
        return get_data_converter(
            self.plane_original_np_dtype, getattr(np, self.filterting_dtype)
        )

    @cached_property
    def detection_dtype(self) -> np.dtype:
        working_dtype = getattr(np, self.filterting_dtype)
        if np.issubdtype(working_dtype, np.integer):
            # already integer, return it
            return working_dtype

        max_int = get_max_possible_int_value(working_dtype)
        if max_int <= get_max_possible_int_value(np.uint32):
            return np.uint32
        return np.uint64

    @cached_property
    def clipping_value(self) -> int:
        return (
            get_max_possible_int_value(getattr(np, self.filterting_dtype)) - 2
        )

    @cached_property
    def threshold_value(self) -> int:
        return (
            get_max_possible_int_value(getattr(np, self.filterting_dtype)) - 1
        )

    @cached_property
    def soma_centre_value(self) -> int:
        return get_max_possible_int_value(getattr(np, self.filterting_dtype))

    @property
    def tile_dim1(self) -> int:
        return self.soma_diameter * 2

    @property
    def tile_dim2(self) -> int:
        return self.soma_diameter * 2

    @property
    def plane_dim1(self) -> int:
        return self.plane_shape[0]

    @property
    def plane_dim2(self) -> int:
        return self.plane_shape[1]

    @property
    def n_processes(self) -> int:
        n = get_num_processes(min_free_cpu_cores=self.n_free_cpus)
        return max(n - 1, 1)


def setup_tile_filtering(plane: np.ndarray) -> Tuple[int, int]:
    """
    Setup values that are used to threshold the plane during 2D filtering.

    Returns
    -------
    clipping_value :
        Upper value used to clip planes before 2D filtering. This is chosen
        to leave two numbers left that can later be used to mark bright points
        during the 2D and 3D filtering stages.
    threshold_value :
        Value used to mark bright pixels after 2D filtering.
    """
    max_value = get_max_possible_int_value(plane)
    clipping_value = max_value - 2
    thrsh_val = max_value - 1

    return clipping_value, thrsh_val
